- [x] specifying the initial edges as 1-dir node edges,
    - [ ] weights,
    - [x] names,
    - [x] action names (edge names are unique, action names are unique-to-source,)
    - [ ] the probability of an edge,
        - [ ] being the most probable edge,
    - [ ] minimum transitions from a state,
    - [ ] maximum transitions from a state,
    - [ ] which states are "complete" (that is, that an input sequence can be considered satisfactorily terminal),
    - [ ] whether a machine is complete,
    - [x] whether a machine is final (complete and terminal),
- [x] the ability to list
    - [x] a node's edges (in/out/both,)
    - [ ] a node's actions (in/out/both,)
    - [x] whether a node is terminal,
        - [x] whether the machine is at a terminal node,
- [ ] to specify for a graph
    - [ ] min/max edge count,
    - [ ] whether to tolerate islands,
    - [ ] whether to links should be 1d/2d/either,
    - [ ] whether the state machine is fixed (not implementing for now,)
    - [ ] whether forcing (making a change outside the edge graph) is permitted (not implementing for now,)
    - [ ] whether names are `allowed|disallowed|optional`,
    - [ ] whether action names are `allowed|disallowed|optional`,
    - [ ] whether edges may be in more than one group,
- [ ] ~~for non-fixed machines, (not implementing for now,)~~
    - [ ] ~~to add edges~~,
    - [ ] ~~to remove edges~~,
    - [ ] ~~to remove nodes (and thus all the related edges,)~~
    - [ ] ~~to have a sane way to validate afterwards~~
- [ ] attached data,
    - [ ] which is transactionally applied,
    - [ ] which is available to all validation hooks,
- [ ] validation hooks on
    - [ ] walking an edge,
    - [ ] entering/exiting a node,
    - [ ] changing data (which can happen with or distinctly from a transition, but always atomically w/ validation),
- [ ] notification hooks on
    - [ ] any change,
    - [ ] enter/exit a node,
    - [ ] walk an edge,
    - [ ] execute a named action,
    - [ ] data change,
    - [ ] init,
    - [ ] non-matching event
- [x] the ability to generate
    - [x] flowchart representations
        - [x] as DOT strings
        - [ ] prolly using viz.js (graphviz emscriptened to yerbaschmidt)
    - [ ] uml statechart representations?
    - [ ] sdl representations?
    - [ ] nfa representations? (see comments below, thanks @patater)
    - [ ] drakon representations?
        - [ ] from within gviz/viz.js?
    - [ ] harel statecharts?
- [ ] the ability to
    - [ ] save a state machine state,
    - [ ] load/create from a state machine state,
    - [ ] validate an abstract state machine state,
    - [ ] keep and rewind a state history (thanks @kz),
    - [ ] autocreate an api (that is, action "melt" on machine auto-gets api method equiv `.melt()`)
        - [ ] with optional prefixes
    - [ ] consume `.dfa` files?
    - [ ] compare two state machines?
    - [ ] check `is_changing`
    - [ ] describe edges as members of groups
- [ ] improved nature of states (all thanks burny who isn't on gh zomg)
    - [ ] states as objects rather than strings
        - [ ] makes inheritance easier
        - [ ] makes heirarachy easier
        - [ ] makes state-associated data easier (eg walking state now has frame#)
        - [ ] makes underlying impl much harder
    - [ ] state subtypes
    - [ ] heirarchal states
        - [ ] triggered by subordinate on transfer callback to superior
        - [ ] "or polling"
    - [ ] multiple concurrent states (keanu mind blown.gif)
- [ ] for convenience,
    - [ ] a fluent api for creation
    - [ ] a DOT-like string api for creation

difference between event and action: if action isn't handled, it's an error; if event, meh
